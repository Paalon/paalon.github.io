# モジュール

Juliaにおけるモジュールは別々の変数ワークスペースです。つまり、新しいグローバルスコープを導入します。それらは構文的に`module Name ... end`の内側として区切られています。モジュールは、コードが他の誰かと一緒に使用されるときに、名前の競合を心配することなく、トップレベルの定義（別名グローバル変数）を作成することを可能にします。モジュール内では、他のモジュールのどの名前を（インポートによって）表示するかを制御したり、名前を公開することを（エクスポートを介して）指定することができます。

次の例はモジュールの主な機能を説明しています。実行できるわけではありませんが、理解しやすくするために載せています。

```julia
module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

importall OtherLib

export MyType, foo

struct MyType
	x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = println(io, "MyType $(a.x)")
end
```

モジュールの中身はインデントしていないことに注意してください。これは、通常ファイル全体がインデントされるためです。

このモジュールは型`MyType`と２つの関数を定義しています。関数`foo`と型`MyType`はexportされているため、他のモジュールの中にimportすることができます。関数`bar`は`MyModule`専用です。

文`using Lib`が意味するのは、必要に応じて名前を解決するために`Lib`と呼ばれるモジュールを利用できるということです。現在のモジュールに定義されていないグローバル変数が見つかった場合、システムは`Lib`によってエクスポートされた変数の中から変数を検索し、そこに見つかった場合はインポートします。 つまり、現在のモジュール内のそのグローバルのすべての使用は、`Lib`内のその変数の定義に解決されます。

文`using BigLib: thing1, thing2`は`using BigLib.thing1, BigLib.thing2`の構文上の省略形です。

`import`キーワードは、`using`と同じ構文をサポートしますが、一度に１つの名前でしか動作しません。`using`とは違って、`import`は検索されるモジュールには追加しません。関数を新しいメソッドで拡張するために`import`を使ってインポートする必要がある点でも、 `import`は`using`とは異なります。

上記の`MyModule`では、標準の`show`関数にメソッドを追加したいので、`import Base.show`と書く必要がありました。名前を使用してしか見えない関数は、拡張することはできません。

変数を`using`または`import`を通して表示すると、モジュールはその中に同じ名前の変数を作成しないことがあります。 インポートされた変数は読み取り専用です。 グローバル変数に割り当てることは、常に現在のモジュールが所有する変数に影響します。そうでない場合は、エラーが発生します。

## モジュールの使い方の概要

モジュールを読み込むには、主に２つのキーワードが使われます。`using`と`import`です。２つの違いを理解するために、次の例を考えましょう。

```julia
module MyModule

export x, y

x() = "x"
y() = "y"
p() = "p"

end
```

このモジュールでは、関数`x`と`y`は（キーワード`export`を使って）exportされていて、関数`p`はexportされていません。モジュールとその内部の関数を現在の作業領域に読み込む方法にはいくつかの違う方法があります。

| 読み込みコマンド                        | スコープにもってこられるもの                           | メソッド拡張で利用可能なもの                           |
| ------------------------------- | ---------------------------------------- | ---------------------------------------- |
| `using MyModule`                | `export`された全ての名前（`x`と`y`）と`MyModule.x`, `MyModule.p` | `MyModule.x`, `MyModule.y`, `MyModule.p` |
| `using MyModule.x, MyModule.p`  | `x`と`p`                                  |                                          |
| `using MyModule: x, p`          | `x`と`p`                                  |                                          |
| `import MyModule`               | `MyModule.x`, `MyModule.y`, `MyModule.p` | `MyModule.x`, `MyModule.y`, `MyModule.p` |
| `import MyModule.x, MyModule.y` | `x`と`p`                                  | `x`と`p`                                  |
| `import MyModule: x, p`         | `x`と`p`                                  | `x`と`p`                                  |
| `importall MyModule`            | `export`された全ての名前（`x`と`y`）                | `x`と`y`                                  |

### モジュールとファイル

ファイルとファイル名はモジュールとはほとんど関係がありません。モジュールはモジュールの表現とだけ関連付けられます。１つのモジュールが複数のファイルに分かれていても良いし、１つのファイルに複数のモジュールが含まれていてもよいです。

```julia
module Foo

include("file1.jl")
include("file2.jl")

end
```

異なるモジュールに同じコードを含めると、mixinのような動作をさせられます。 これを使って異なる基底定義を持つ同じコードを走らせることができます。例えば、ある演算子の「安全な」バージョンでコードをテストすることができます。

```julia
module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end
```

### 標準モジュール

３つの重要な標準モジュールがあります。MainとCoreとBaseです。

Mainはトップレベルのモジュールで、JuliaはMainを現在のモジュールとしてセットした状態で起動します。プロンプトで定義された変数はMainに登録され、`whos()`はMainの中にある変数をリストアップします。

Coreは言語に「組み込まれている」とみなされる全ての識別子を持っています。つまり、コア言語の一部でありライブラリではありません。全てのモジュールは暗黙的に`using Core`が指定されています。そうでなければCoreの定義がないため、何もできなくなってしまうからです。

Baseは標準ライブラリ（base/の内容）です。全てのモジュールで大抵Baseを必要とするため、全てのモジュールは暗黙的に`using Base`を含むようになっています。

### デフォルトトップレベル定義と裸モジュール

`using Base`に加えて、モジュールは自動的に`eval`関数の定義を含むようにもなっています。`eval`関数はそのモジュールの中身の表現を評価します。

もし、これらのデフォルト定義が必要ない場合は、代わりにキーワード`baremodule`を使うことによってモジュールを定義することができます（注意：上記のように、この場合でも`Core`は読み込まれます）。`baremodule`では標準の`module`はこのように見えます。

```julia
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
eval(m, x) = Core.eval(m, x)

...

end
```

### 相対モジュールパスと絶対モジュールパス

`using Foo`文が与えられると、システムはトップレベルモジュールの内部テーブルを参照してFooという名前のテーブルを探します。 モジュールが存在しない場合、システムは`require(:Foo)`を試みます。これは通常、インストールされたパッケージからコードをロードします。

ただし、一部のモジュールにはサブモジュールが含まれているため、トップレベルではないモジュールにアクセスする必要があることがあります。 これを行うには2つの方法があります。 最初は、絶対パスを使用することです（例えば`using Base.Sort`など）。2つ目は相対パスを使用することです。これにより、現在のモジュールまたはそのモジュールを含むモジュールのサブモジュールを簡単にインポートできます。

```julia
module Parent

module Utils
...
end

using .Utils

...
end
```

ここでモジュール`Parent`はサブモジュール`Utils`を含み、`Parent`中のコードは

ここではモジュール`Parent`にサブモジュール`Utils`があり、`Parent`には`Utils`の内容が表示されます。 これは、使用パスをピリオドで開始することによって行われます。 先頭の期間を追加すると、モジュール階層の追加レベルが上がります。 例えば、`using ..Utils`を使うと、`Parent`自体ではなく`Parent`の囲い込みモジュールで`Utils`が検索されます。

relative-import修飾子は、`using`文と`import`文でのみ有効であることに注意してください。

### モジュールファイルパス

グローバル変数`LOAD_PATH`には、`require`を呼び出すときにジュリアがモジュールを検索するディレクトリが含まれています。 それは`push!`を使用して拡張することができます。

```julia
push!(LOAD_PATH, "/Path/To/My/Module/")
```

この文を`~/.juliarc.jl`ファイルに入れると、Juliaの起動時に`LOAD_PATH`が拡張されます。 あるいは、環境変数`JULIA_LOAD_PATH`を定義してモジュールのロードパスを拡張することもできます。

### 名前空間雑録

名前が修飾されている場合（`Base.sin`など）、エクスポートされていなくてもアクセスできます。 これは、デバッグ時に便利です。 また、修飾名を関数名として使用してメソッドを追加することもできます。 しかし、構文上の曖昧さが原因で、名前にシンボルのみが含まれている別のモジュール（たとえば、`Base.+`など）の関数にメソッドを追加する場合は、`Base.:+`を使用して参照する必要があります 。 演算子が複数の長さの文字の場合、`Base.:(==)`のようにに括弧で囲む必要があります。

マクロ名は、インポートおよびエクスポート文に`@`で書き込まれます。例えば、`import Mod.@mac`などとしてです。他のモジュールのマクロは、`Mod.@mac`または`@Mod.mac`として呼び出すことができます。

構文`M.x = y`は、別のモジュールでグローバルを割り当てるのには機能しません。 グローバル割り当ては常にモジュールローカルです。

変数名は、`global x`と宣言して割り当てることなく、 「予約」することができます。 これにより、ロード時に初期化されたグローバルの名前の競合が防止されます。

### モジュール初期化とモジュールのプリコンパイル

大きなモジュールは読み込むのに何秒かかかることがあります。これはモジュール中の全ての文を実行することが、大量のコードをコンパイルすることに関係していることがよくあるからです。この時間を縮めるために、Juliaはプリコンパイルされたバージョンのモジュールを作る機能を提供しています。

増分プリコンパイルされたモジュールファイルを作成するには、`__precompile__()`をモジュールファイルの一番上（`module`が始まる前）に加えてください。これにより初めてインポートされるときに自動的にコンパイルされます。または`Base.compilecache(modulename)`を手動で呼び出すこともできます。結果のキャッシュファイルは`Base.LOAD_CACHE_PATH[1]`に格納されます。その後、依存関係のいずれかが変化するたびに、モジュールはインポート時に自動的に再コンパイルされます。依存関係は、インポートするモジュール、Juliaビルド、含まれるファイル、またはモジュールファイルに`include_dependency(path)`で宣言された明示的な依存関係です。

ファイル依存関係の場合、`include`によってロードされたファイル、もしくは`include_dependency`によって明示的に追加されたファイルの変更時刻（mtime）が変更されていないか、または最も近い秒に切り捨てられた変更時間に等しいかどうかを調べることによって変更が決定されます。（秒未満の精度でmtimeをコピーする）。また、検索ロジックによって選択されたファイルへのパスが、プリコンパイルファイルを作成したパスと一致するかどうかも考慮されます。

また、現在のプロセスにすでにロードされている依存関係のセットを考慮に入れ、実行中のシステムとプリコンパイル・キャッシュとの間の非互換性を避けるために、ファイルが変更または消滅してもそれらのモジュールを再コンパイルしません。実行中のシステムに反映されたソースに変更を加えたい場合は、変更したモジュール上で`reload("Module")`を呼び出す必要があります。

また、モジュールをプリコンパイルすると、そこにインポートされたモジュールが再帰的にプリコンパイルされます。モジュールをプリコンパイルするのが安全でないことが分かっている場合は、`__precompile __(false)`をモジュールファイルに入れて、`Base.compilecache`でエラーが発生するようにする必要があります。他のプリコンパイルされたモジュール）。

`__precompile __()`は、その依存関係のすべてが`__precompile __()`を使用していない限り、モジュール内で使用すべきではありません。そうしないと、モジュールをロードするときにランタイムエラーが発生する可能性があります。

ただし、モジュールがプリコンパイルで動作するようにするには、実行時にコンパイル時に発生する可能性のある初期化ステップを明示的に分離するようにモジュールを変更する必要があります。この目的のために、Juliaでは、モジュールで実行時に実行する必要がある初期化ステップを実行する`__init__()`関数を定義することができます。この関数は、コンパイル時には呼び出されません（`--output-*`または`__precompile__()`）。もちろん、必要に応じて手動で呼び出すこともできますが、デフォルトでは、コンパイルされたイメージにキャプチャする必要はありませんし、そうでないようにしても構いません。インクリメンタル・コンパイル（`--output-incremental=yes`）にロードされている場合を含め、モジュールがプロセスにロードされた後に呼び出されますが、フル・コンパイル・プロセスにロードされている場合は含まれません。

特に、モジュール内で`function __init__()`を定義すると、Juliaは実行時に初めてモジュールがロードされた直後（つまり、`import`、`using`、または`require`）に`__init__`を呼び出します（つまり、`__init__`は一度だけ呼び出され、モジュール内のすべてのステートメントが実行された後にのみ）。モジュールが完全にインポートされた後に呼び出されるため、サブモジュールやその他のインポートされたモジュールには、そのモジュールの`__init__`の**前**に呼び出される`__init__`関数があります。

`__init__`の2つの典型的な使い方は、外部Cライブラリのランタイム初期化関数を呼び出し、外部ライブラリから返されるポインタを含むグローバル定数を初期化することです。たとえば、実行時に`foo_init()`初期化関数を呼び出さなければならないCライブラリ`libfoo`を呼び出しているとします。 `libfoo`によって定義された`void *foo_data()`関数の戻り値を保持するグローバル定数`foo_data_ptr`も定義したいと仮定します。この定数は実行時（コンパイル時ではなく）で初期化する必要があります。走るあなたはモジュールで次の`__init__`関数を定義することでこれを達成できます：

```julia
const foo_data_ptr = Ref{Ptr{Void}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Void, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Void}, ())
    nothing
end
```

`__init__`のような関数内でグローバルを定義することは完全に可能であることに注意してください。これは動的言語を使用する利点の1つです。しかし、これをグローバルスコープで一定にすることで、型がコンパイラに認識され、より最適化されたコードを生成できるようにすることができます。明らかに、`foo_data_ptr`に依存するモジュール内のその他のグローバルも、`__init__`で初期化する必要があります。

`ccall`で生成されないほとんどのJuliaオブジェクトを含む定数は、`__init__`に配置する必要はありません。それらの定義をプリコンパイルし、キャッシュされたモジュールイメージからロードすることができます。これには、配列のような複雑なヒープ割り当てオブジェクトが含まれます。しかし、未処理のポインタ値を返すルーチンは、実行時にプリコンパイルを実行するために呼び出さなければなりません（Ptrオブジェクトはisbitsオブジェクトの中に隠されていない限り、ヌルポインタになります）。これには、Julia関数`cfunction`と`pointer`の戻り値が含まれます。

ディクショナリとセットの型、または一般的には`hash(key)`メソッドの出力に依存するものは、扱いにくいケースです。キーが数値、文字列、記号、範囲、`Expr`、またはこれらの型のコンポジション（配列、タプル、セット、ペアなど）である一般的なケースでは、それらはプリコンパイルするのが安全です。しかし、`Function`や`DataType`やハッシュメソッドを定義していない一般的なユーザ定義型のような他のいくつかのキータイプでは、フォールバックハッシュメソッドは（`object_id`を介して）オブジェクトのメモリアドレスに依存するため、実行ごとに変更します。これらのキータイプのいずれかを持っているか、またはわからない場合は、`__init__`関数の中からこの辞書を初期化することができます。また、`ObjectIdDict`ディクショナリ・タイプを使用することもできます。このタイプは、コンパイル時に初期化するのが安全なように、プリコンパイルによって特別に処理されます。

プリコンパイルを使用する場合は、コンパイル・フェーズと実行フェーズの区別を明確にすることが重要です。このモードでは、Juliaがコンパイルされたコードを生成するスタンドアロンインタプリタではなく、任意のJuliaコードを実行できるコンパイラであることがはっきりしていることがよくあります。

他の知られている失敗するシナリオは、

1.  グローバルカウンタ（たとえば、オブジェクトを一意に識別しようとする場合）次のコードスニペットを考えてみましょう。
```julia
mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end
```
このコードの目的はすべてのインスタンスに一意のIDを与えることでしたが、コンパイルの最後にカウンタ値が記録されます。 このインクリメンタルにコンパイルされたモジュールのその後の使用はすべて、同じカウンタ値から開始されます。

`object_id`（メモリポインタをハッシュすることによって動作する）にも同様の問題があることに注意してください（下記の`Dict`の使用方法に関する注意を参照してください）。

マクロを使用して`@__MODULE__`をキャプチャし、それを現在のカウンタ値だけに格納する方法もありますが、このグローバル状態に依存しないようにコードを再設計する方がよい場合があります。

2.  連想集合（`Dict`や`Set`など）を`__init__`で再ハッシュする必要があります。 （将来、初期化関数を登録するためのメカニズムが提供されるかもしれません。）
3.  ロード時まで持続するコンパイル時の副作用に依存します。 例としては、他のJuliaモジュールの配列や他の変数を変更する; ファイルやデバイスを開くためのハンドルを維持する。 他のシステムリソース（メモリを含む）へのポインタを格納する。
4.  ルックアップパス経由ではなく直接参照することにより、別のモジュールからグローバル状態の偶発的な「コピー」を作成する。 たとえば、（グローバルスコープ内で）
```julia
#mystdout = Base.STDOUT #= will not work correctly, since this will copy Base.STDOUT into this module =#
# instead use accessor functions:
getstdout() = Base.STDOUT #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.STDOUT #= also works =#
```

ユーザーが他の誤った動作状況を回避するためにコードをプリコンパイルしている間に実行できる操作には、いくつかの追加の制限があります。

1.  `eval`を呼び出して、別のモジュールで副作用を引き起こします。 また、インクリメンタル・プリコンパイル・フラグが設定されているときに警告が出されます。
2.  `__init__()`が開始された後のローカルスコープからの`global const`文（このためにエラーを追加する計画についてはissue#12010を参照）
3.  モジュールを置き換える（または`workspace()`を呼び出す）ことは、増分プリコンパイルを実行する際の実行時エラーです。

注意すべき他のいくつかの点は次のとおりです。

1.  ソースファイル自体が変更された後（`Pkg.update`を含む）、`Pkg.rm`の後にクリーンアップが行われないと、コードの再ロード/キャッシュ無効化は実行されません
2.  再構成された配列のメモリ共有動作は、プリコンパイルによって無視されます（各ビューは独自のコピーを取得します）
3.  コンパイル時と実行時との間でファイルシステムが変更されないことを期待する。 実行時にリソースを見つけるには`@__FILE__ `/`source_path()`、BinDepsの`@checked_lib`マクロです。 時にはこれは避けられないこともあります。 しかし、可能であれば、コンパイル時にリソースをモジュールにコピーして、実行時にリソースを見つける必要はありません。
4.  `WeakRef`オブジェクトとファイナライザは現在、シリアライザによって適切に処理されていません（これは、今後のリリースで修正される予定です）。
5.  通常、`Method`、`MethodInstance`、`MethodTable`、`TypeMapLevel`、`TypeMapEntry`、およびこれらのオブジェクトのフィールドなどの内部メタデータオブジェクトのインスタンスへの参照をキャプチャしないようにすることが最善です。これは、シリアライザを混乱させる可能性があり、 これを行うことは必ずしも間違いではありませんが、システムがこれらのいくつかをコピーし、他の一意のインスタンスを作成するように準備する必要があります。

増分プリコンパイルをオフにすることは、モジュール開発中に役立つことがあります。 コマンドラインフラグ`--compiled-modules={yes|no}`を使用すると、モジュールのプリコンパイルをオンまたはオフに切り替えることができます。 Juliaを`--compiled-modules=no`で起動すると、モジュールとモジュールの依存関係を読み込むときに、コンパイルキャッシュ内の直列化モジュールは無視されます。`Base.compilecache`は引き続き手動で呼び出すことができ、モジュールの`__precompile__()`ディレクティブを尊重します。 このコマンドラインフラグの状態は`Pkg.build`に渡され、パッケージをインストール、更新、および明示的にビルドする際の自動プリコンパイルトリガを無効にします。